  int n=87;
  int m=n++;//m=n++=87 , n=88;       
  int t=++n;//t=++n=89 ,n=89;
  cout<<n++<<" ";//n++=89, n++=90;
  cout<<m++<<" "<<t; //87 , 89;
NOTE: tính từng dòng code từ trên xuống  
--------------------------------------------------------------------------
  int a=100,b=200;
  int c=a++ + ++b;//a++ = 100 + ++b=201 => c=301 , a++101 ,++b =201 
  int d=a++ + b++;//a++ =101 + b++=201 => d=302 ,a++=102 ,b++=202
  cout<<a<<" "<<b<<" "<<c<<" "<<d; //a=102 , b=202 , c=301 , d =302 
--------------------------------------------------------------------------
n%10 %2== 0 Kiểm tra chữ số tận cùng là chẵn / chữ số tận cùng là bội số 2 
n%10 == 2	Kiểm tra chữ số tận cùng là 2
--------------------------------------------------------------------------
if(dtb>=8) cout<<"gioi";
else if(dtb>=6.5) cout<<"kha";
NOTE: đúng hay sai => đúng nhé vì nếu trong if else thì nó in 1 lần 
điều kiện dtb>=8 đúng thì nó in gioi còn nếu sai thì nó vẫn in khá.
--------------------------------------------------------------------------
đối với hàm max,min trên 3 chữ số thì dùng thư viện algorithm và có dấu {}
--------------------------------------------------------------------------
khai báo hằng số : const double pi=3.14;
chu vi diện tích hình tròn :
cv=2*pi*r; | dt=pi*r*r;
chu vi diện tích hình chữ nhật :
cv=2*(chiều dài+chiều rộng); | dt= chiều dài x chiều rộng;
--------------------------------------------------------------------------
hàm setw và setfill nằm trong thư viện iomanip 
cout<<setw(6)<<setfill('0')<<n;
+ setw dùng để đặt tối thiểu chữ số => setw(6)
+ setfill dùng đặt kí tự nếu thiếu chữ số => setfill('#')
nó sẽ đặt trước số nếu n=345 vì có 3 chữ số nên dùng setw
=> ###850 , 000850 trở thành 6 số vì setw yêu cầu 6 số 
--------------------------------------------------------------------------
 số thứ 1 là số lớn nhất <=a mà chia hết cho b
ví dụ số 7 thì giảm xuống thành 6 chia hết cho b =>a/b*b 
 số thứ 2 là số nhỏ nhất >=a mà chia hết cho b
ví dụ 6/2 = 3 thì lấy 3*3 = 9 vì nó lớn hơn a 
=> (a+b-1)/b*b hoặc a/b*b+b 
--------------------------------------------------------------------------
Tam giác hợp lệ thì phải có 6 điều kiện : 
3 cạnh đều dương, và tổng hai cạnh luôn lớn hơn cạnh còn lại
--------------------------------------------------------------------------
Hoán đổi dùng hàm swap(a,b) hoặc gán biến
int tmp=b;
b=a,a=tmp;
--------------------------------------------------------------------------
Mua nước : khi vào hàng hóa muốn tiết kiệm thì tính a,b
nếu chai a mà ít tiền hơn b thì mua luôn
còn chai b mà ít tiền hơn thì chia ra 2 trường hợp
nếu số lít chẳn thì n/2*b còn lẻ n/2*b+a  
--------------------------------------------------------------------------
DOMINO : nó không được phép đặt ra ngoài thì nó là kiểu int (m*n)/2
--------------------------------------------------------------------------
Lát Gạch : n dọc m ngang a là điều kiện phủ gạch chiều dọc và ngang 
không được phép phá vỡ các viên đá thì phải làm tròn lên để phủ dư 
ví dụ dọc 60cm ngang 70cm gạch 30cm thì lấy dọc/gạch=30cm lót được 2 viên 
nếu dọc%gạch==0 d=n/a; else d=n/a+1; vì có thể lót dư 
nếu ngang%gạch==0 ng=m/a; else ng=m/a+1;
cout<<dọc*ngang để phủ hết quảng trường 
--------------------------------------------------------------------------
VỊ TRÍ ẾCH NHẢY : xét K bước nhảy của nó 
ví dụ 5 bước thì bước 1 nó nhảy phải thì có 3 phải 2 trái 
nếu k chẳn thì phải=k/2; trái=k/2; vì tính cả hai
nếu k lẻ thì phải=k/2+1; trái=k/2 vì 5 bước thì bước đầu là bên phải 
cout<<tổng bước phải * a - tổng bước trái * b
tính số lần nó bước hết trái và phải 
tại sao '-' vì nó nhảy sang dương có thể nhảy lùi về 0 hoặc sang âm 
--------------------------------------------------------------------------
ĐỒNG XU : ví dụ ta có 15 ngàn mà muốn đổi ra tờ 5 xu thì ta s/n = 3 tờ 
được phép có nhiều đồng tiền thì ta có thể cộng 1 
nếu s%n chẳn thì s/n; lẻ s/n+1 
--------------------------------------------------------------------------
LEO CẦU THANG : có thể 1 bước , 2 bước , 3 bước ...
Số bước tối thiểu : (n + 1) / 2 gồm trường hợp chẵn và lẻ
MAX thì 1 bước thì nhiều bước nhất , MIN thì lại ít bước 
n=10,m=2 thì m nó có thể đi 1 bước hoặc 2 bước để đạt đủ 10 bước  
số lần di chuyển là bội số của một số nguyên m thì tìm bước tối thiểu 
sau đó chia m chẳn thì 
đặt a=min // là số lần bước tối thiểu khi tính xong 
b=m // bội số m để chia 
nếu a%b==0 cout<<a; vì nó đi 1 bước 
else cout<<(a/b+1)*b vì nó đi 2,3... bước  // để tính bội số tiếp theo 
a/b*b+b có thể dùng nhưng không thể trực tiếp làm tròn 
--------------------------------------------------------------------------
TỔNG ĐỘ CHÊCH LỆCH vd : 1236 -> 1+1+1+3=6 
thì ta lấy cái cuối cùng rồi xóa rồi lấy biến sum+=(r-n%10);
SO SÁNH CÁC SỐ LỚN NHẤT
thì đặt 1 số cuối rồi so sánh từng số nếu số đó > thì cập nhật
if(n%10>max) max=n%10; n/=10;
--------------------------------------------------------------------------
ĐỐI VỚI CÁC BÀI XÉT CHẲN LẺ THÌ DÙNG CÔNG THỨC : (a+b+4)/5 
GHÉP SỐ : thì ta dùng hàm min để tìm số nhiều chữ số nếu trùng thì lấy số
trùng đó trừ đi tìm số -> vd: k32=min(k3,k2-256) vì k256 đã tìm 
CHIA XU : nên đặt gán cộng tổng lại vì chia xu cho 3 người nên 
nếu chia hết cho 3 người thì chiaxu/3 >=a , >=b >=c mới chia đều được
nếu không chia hết thì không chia được vì chiaxu xu ít hơn 1 trong 3 
SỰ HÀO PHÓNG : 5 người bỏ ra n đồng xu quy rồi tìm trung bình đặt xu 
quy luật ta nên đặt gán tổng của 5 người rồi tìm điều kiện
if(tong%5==0) thì ta đặt gán là b=tong/5; đề bài kêu là tìm in ra -1 
if(b!=0) cout<<b;  còn else cout<<-1; 
TÌM SỐ PHÚT CÒN LẠI : thì lấy tổng số phút 1 ngày - số phút * giờ - phút 
ĐỔI THỜI GIAN vd 392 đổi sang giờ , phút , giây 
vì n là giây nên ta lấy 60*60 nên tính 1 giờ rồi chia phút chia giây 
THỜI GIAN KẾ TIẾP : tìm sau k phút thì giờ phút nó là mấy 
trước tiên ta giữ lại k phút còn lại 1 ngày của nó lấy k%784 //28*28=784 
int time=h*28+m+k  // tổng số phút đã trôi qua
int gio=time/28,phut=time%28;
TÌM KÍ TỰ : tồn tại 1 chữ C và 2 dấu + c=='C' , c=='+' 
đặt 2 biến dem để so sánh 
if(dem>=1&&dem2>=2) cout<<"Yes" 
SẮP XẾP SỐ : thì ta tìm hàm max , min sau đó tìm số chính giữa 
lấy a+b+c-max_val-min_val là ra số chính giữa 
TÍNH TỔNG SỐ : khi thấy chữ số thì ta cộng dồn vào thì lấy sum+=c-48; 
CHỈ SỐ BMI : thì ta nên dùng float để tránh lấy thiếu 
vd int chieucao=h/100 = 1.51 mà kiểu int thì ta chỉ lấy 1 thôi 
nên dùng float chieucao=h/100.0  
__________________________________________________________________________
while(n>9){
    int sum=0;    //phải đặt sum bên ngoài while phụ vì nó so sánh 
    while(n!=0){
      sum=n%10; //phải đặt sum kiểm tra từng số 
      n/=10;
    }
    n=sum;  
  }
CHỮ SỐ ĐẦU TIÊN VÀ CUỐI CÙNG 
ll n ; cin>>n;
  int r=n%10;    // lấy chữ số cuối cùng 
  while(n>=10){
    n/=10;       // duyệt đến khi còn 1 chữ số 
  }
  cout<<n<<" "<<r;
--------------------------------------------------------------------------
switch (val) {
  case 1:
    // code
    break;
  case 2:
    //code
    break;
  .....
  case n:
    // code
    break;
  default :
    // code
}
các case chỉ : không có mở/đóng {} 
muốn case 1->10 thì ta dùng ... ở giữa các case 
switch (val) {
  case 1 ... 10:
      // code
      break;
}
--------------------------------------------------------------------------
+ for ( [Câu lệnh khởi tạo] ; [Điều kiện lặp] ; [Câu lệnh cập nhật] ){
    // Code trong vòng lặp
  }
+ while ( [Điều kiện lặp] ){
    // Code trong vòng lặp
  {
+  do {
      // Code trong vòng lặp
  } while ( [Điều kiện lặp] );
NOTE : + biết trước vòng lặp thì dùng for  
+ while không áp dụng số 0 khi đếm nên dùng if else để đặt n==0 cout<<1;
nên return vì không return nó sẽ chạy từng dòng xuống dưới 
n%10 dùng để lấy số
n/10 dùng để xóa số 
--------------------------------------------------------------------------
for(int i=1;i<15;i*=2) {
    cout<<i<<" ";    // 1 2 4 8 -> 8*2=16 nó vượt 15 nên dừng 
  }
  cout<<i;   // báo lỗi vì chưa khai báo 
--------------------------------------------------------------------------
for(int i=1;i<=15;i++){
    cout<<i<<" "; 
    if(i%2==0) i++;
    else i+=2;   
}
i=1 cout<<i ra 1 xuống dòng 1%2==1 
i=1 vào else i=3 trở về i++ = 4 <=15 
i=4 vào if i=5 trở về i++ = 6 <=15 
i=6 vào if i=7 trở về i++ = 8 <=15
i=8 vào if i=9 trở về i++ = 10 <=15
i=10 vào if i=11 trở về i++ = 12 <=15
i=12 vào if i=13 trở về i++ = 14 <=15
i=14 vào if i=15 trở về i++ = 16 >=15 nên sai 
i =  1 4 6 8 10 12 14 
NOTE : tăng trong if else xong thì sẽ tăng 1 đơn vị trong for 
int i = n + 1;  // i = 45 nếu n = 44 // khi >n ,< n thì i=n+1 , n-1 
while (true) { 
    if (i % 17 == 0) {  //i=45 thì sai nên nó không chạy if mà xuống i++
        cout << i << endl;
        break;
    }
    i++; //tăng đơn vị đến khi nào nó chạy được trong if 
}
-------------------------------------------------------------------------
Tìm số nhỏ nhất >=a chia hết cho b
a=23 , b=7 
for(int i=a; ;i++){  // đến khi nó chia hết cho b thì nó dừng
  if(i%b==0) {
    cout<<i; 
    break;      // phải có điều kiện dừng break 
  }
}
--------------------------------------------------------------------------
IN KÍ TỰ KẾ TIẾP  ví dụ : a b c d e 
ll n; cin>>n;
  for(char i=97;i<97+n;i++) {
    cout<<i<<" ";
  }
97+5=102 -> a b c d e f vì i<97+n nên đến e là dừng   
ll n; cin>>n;
  char c='a';
  int dem=0;
  while(dem<n){ // 0<5 
    cout<<c<<" "; // a 
    c++; // b 
    dem++; //2<5 quay về thành b , c , d , e 
  }
--------------------------------------------------------------------------
n*n-1 và 2*n-1 khác nhau hoàn toàn  vd : n=37 
n*n -> 1369 - 1 còn 2*n -> 74 - 1 
nên khai báo long long cho biến gán vì có thể bị tràn và ép kiểu 1ll
--------------------------------------------------------------------------
các bài toán tìm ước , số chính phương  : duyệt từ 1 đến căn n : i*i<=n 
n chia hết cho nó, thì số đó là ước. // bài tìm ước 
phải đủ 2 cách làm mới tìm đủ ước của nó n%i==0 và i!=n/i 
for(int i=1;i*i<=n;i++) cout<<i*i<<" "; // bài chính phương 
--------------------------------------------------------------------------
Số nguyên tố là số chia hết cho 1 và chính nó bắt đầu là số 2 
--------------------------------------------------------------------------
MUA BIA ví dụ n=138 mà bia giá 28 đồng cứ 3 vỏ là được đổi 1 chai bia 
bia=n/28 , vo=bia // để đổi bia 
if(vo>=3){
  biamoi=vo/3;
  bia+=biamoi;
  vo=vo%3+biamoi; //4 % 3 + 1 = 2 không phải là 1+1=2 
// lấy số vỏ bia còn lại + bia được đổi 
}
(n-3)/2+1 đối với số lẻ ví dụ 7 = 3 vì biểu diễn số nguyên là từ 2,3....
--------------------------------------------------------------------------
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++) cout<<"*";
    cout<<endl;  // phải xuống dòng vì for gốc là i vì nó chạy gốc 
} 
__________________________________________________________________________
for(int i=n;i>=1;i--){
    for(int j=1;j<=n;j++){
      if(j<=n-i) cout<<" ";
      else cout<<"*";
    }
    cout<<endl;
}
nó chạy từ 1<=n // 1<=0 rồi xuống chạy code so sánh 
1<=0 vào trường hợp else in *
1<=n // 1<=1 
1<=1 vào if in " " 2>=1 in * 
1<=2 vào if in " " 2<=2 in " " 3<=2 vào else 4<=2 vào else 5<=2 vào else 
_________________________________________________________________________
int n; cin>>n;
  int dem=1;
  for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
      cout<<dem<<" ";
      dem++;
    }
    cout<<endl;
}
Lập trình chạy từng bước một theo thứ tự vòng lặp khi i=1 
j=1; 1<=5 in ra 1 dem++ lên là 2 khi nào chạy xong for j rồi dừng đến i=2 
sau đó lặp đến khi >=5 là dừng chứ không phải là j=1 ; j<=5 
mà in ra 1 2 3 4 5 
________________________________________________________________________
for(int i=1;i<=n;i++){
    int dem=i;
    for(int j=1;j<=n;j++){
      cout<<dem<<" ";
      dem++;
    } // chạy hết for j thoát ra i++ tăng lên i=2 rồi dem=2 
    cout<<endl;
}
khi i=1 , dem cập nhật là dem=1 chạy xuống for j 
cout<<1; rồi cập nhật lên 2 , 3 , 4 , 5 hết for j biến i++ tăng lên i=2 
khi i=2 , dem cập nhật là dem=2 chạy xuống for j
cout<<2; rồi cập nhật lên 3 , 4 , 5 , 6 hết for j biến i++ tăng lên i=3
_______________________________________________________________________
nên nhớ khi đặt ở for i khi nó chỉ chạy hàng i không chạy j 
muốn có kết quả thì tính j 
for(int i=1;i<=n;i++){
    int dem=i; // khi i=1 cout<<1 
    for(int j=1;j<=i;j++){
      cout<<dem<<" "; // khi i=1 thì 1<=1 hàng j chỉ in 1 số 
      dem+=n-j; // 1+=5-1 = 5 
    }
    cout<<endl;
}
khi i=2 thì j<=2 in 2 số cout<<2 vì đặt dem=i 
+ j=1 2+=5-1 = 6 nên nhớ lập trình chạy từng bước một 
khi i=3 thì j<=3 in 3 số cout<<3 dem=i;
+ j=1 dem+=n-j thì 3+=5-1 = 7
+ j=2 dem+=n-j thì 3+=5-2 = 10 
bài này mặc định cột i==1 thì mặc định còn j==i thì tính j thôi 
-----------------------------------------------------------------------
Ước chung lớn nhất : vd 2!,5! ucln của nó là 2 và 3!,5! ucll là 3 
Khi khai báo biến tổng ta còn phải nhìn công thức nó là 0 hay 1 
vd 1/0! thì = 1 nếu khai báo sum=0 thì nó phần tử đầu tiên 
-----------------------------------------------------------------------
AX+BY=N công thức nguyên không âm : Y=N-AX/B 
Digital root muốn còn 1 số thì 2 vòng while , n>9 và n!=0 cập nhật n
while(n>9){
    int sum=0;       // dùng để cập nhật n 
    while(n!=0){    // để còn 1 chữ số 
      sum+=n%10;
      n/=10;
    }
    n=sum;
}
-----------------------------------------------------------------------
A
B B
C C C
D D D D
E E E E E
F F F F F F 
// khởi tạo biến char c=64+i trong for i 
----------------------------------------------------------------------
TAM GIÁC CÂN :
for(int i=1;i<=n;i++){
    for(int j=1;j<=n-i;j++) cout<<"  ";
    for(int j=1;j<=2*i-1;j++) cout<<"* ";
    cout<<endl;
}
2 vòng for j đều đứng trên 1 hàng (dòng)
vd: i=1 in 4 dấu cách còn j=5 sẽ là vòng lặp thứ hai làm 
----------------------------------------------------------------------
        1 
      2 3 2 
    3 4 5 4 3 
  4 5 6 7 6 5 4 
5 6 7 8 9 8 7 6 5
bài này có 3 vòng j 1 cái n-i cho dấu cách , và cái tăng/giảm
1 bên tăng bên trái còn bên phải là giảm 
for(int j=1;j<=i;j++){
      cout<<dem<<" ";
      dem++;
}
giảm thì dem-=2;
for(int j=1;j<i;j++){
      cout<<dem<<" ";
      dem--;
}
nên j<i thì cái bên phải nó chỉ thực hiện 4 lần cho nó căn bằng 
_____________________________________________________________________
* * * * * * * * *   //0
  * * * * * * *  //1 
    * * * * *  //2 
      * * *  //3 
        *  //4 
đặt i=n ; i>=1 
j<=n-i // 5-5=0 , 5-4=1 , 5-3=2 , 5-2=3 , 5-1=4 cout<<" ";
j<=2*i-1 cout<<"* ";
_____________________________________________________________________
1       1     //i==j thì ta có cột từ i=1 chạy đường chéo đến i=5 
  2   2   
    3     
  4   4   
5       5    //j==n-i+1 có đường chéo phải xuống trái j==5 đến j==1 
là : 5-1+1=5 thì phải j đứng cột 5 mới = 5 thì in ra i 
01010 // ở i=1 ta thấy j%2==0 -> 1 còn i%2==1 ->0  
10101
01010
10101
01010
if(i+j)%2==1 cout<<1; else cout<<0; hoặc if(i%2!=j%2) cout<<1
---------------------------------------------------------------------
TRONG C++ CÓ 3 TỪ KHÓA : TYPEDEF , DEFINE , USING
Typedef là một từ khóa được sử dụng để tạo một tên mới
+ typedef kết thúc bằng dấu ;
      typedef long long ll;
gồm 3 phần "từ khóa"   "kiểu dữ liệu"     "đặt tên" 
define có 3 chức năng : đặt tên mới , định nghĩa giá trị , cú pháp 
+ define bắt đầu bằng dấu # 
#define ll long long    // đặt tên mới 
#define PI 3.14   //định nghĩa giá trị 
#define max 10^9  // định nghĩa giá trị 
NOTE: ĐỊNH NGHĨA ĐƯỢC CẢ SỐ VÀ CHUỖI 
+ using phải có dấu = ở giữa đặt tên và kiểu dữ liệu
using ll = long long;
---------------------------------------------------------------------
HÀM VOID KHI TRONG HAM MAIN LÀ : HAM();
khi ngoài hàm main mà muốn in kết quả thì phải có cout 
void ham(int a, int b, int c){   // trong () gọi là tham số 
}
int main(){
  ham(10,20,30); // hàm mà truyền vào gọi là đối số 
}
HÀM INT,LONG LONG,DOUBLE,FLOAT TRONG MAIN PHẢI CÓ COUT ĐỂ XUẤT RA 
int main(){
  cout<<ham();  // gọi hàm khi muốn in 
}
NGOÀI MAIN KHI IN PHẢI LÀ RETURN;
int ham(){
  cout<<"28tech";
  return 28;     // 
}
ham(); thì nó in mỗi 28tech , cout<<ham() in ra 28tech và 28 
1 hàm chỉ có một câu lệnh return gặp return là dừng 
_____________________________________________________________________
int sum(ll n){
  int sum=0;
  while(n!=0){
    sum+=n%10;
    n/=10;
  }
  return sum;  //4 
}
giá trị trở về nó là bao nhiêu thì thay kiểu trả về theo nó 
vd return sum=4 thì nó nằm trong int còn lớn hơn 10^9 thì ll 
nhập số n nếu lớn 10^9 thì để tham số là long long 
muốn kiểu giá trị ra nhiêu thì đặt kiểu dữ liệu giống nó 
ví dụ in ra trên 10^9 thì kiểu trả về phải là long long 
long long sum(ll n){
  int kq=n*n;  // phải khai báo long long cho gán biến
  return kq;   // kết quả sẽ bị tràn vì biến kq là int 
}
note : kiểu trả về của hàm phải giống với kiểu gán biến 
---------------------------------------------------------------------
nếu muốn chữ số tận cùng của nó là 8 dùng vòng while rồi so sánh
if(sum%10==8) return 1; có thể thay thành return sum%10==8;
while(n) nó giống với while(n!=0) và while(n>0) 
---------------------------------------------------------------------
for(int i = 1; i <= n; i++) giống với while
int i = 1;
while (i <= n) {
    // thân vòng lặp
    i++;      // phải có i++ để tăng lên 
}
Truyền tham trị : Khi bạn thay đổi giá trị biến trong hàm, biến gốc 
bên ngoài không bị ảnh hưởng.
void tang(int x) {
    x = x + 1;
}
int main() {
    int a = 5;
    tang(a);
    cout<<a; // In ra 5, vì 'a' không bị thay đổi
}
Truyền tham chiếu : Khi bạn thay đổi giá trị biến trong hàm, biến gốc
bên ngoài cũng bị thay đổi.
void tang(int &x) {  // Dùng tham chiếu trong C++ 
    x = x + 1;
}
int main() {
    int a = 5;
    tang(a);
    cout<<a; // In ra 6, vì 'a' đã bị thay đổi
}
----------------------------------------------------------------------
TRONG C++ CÓ 3 BIẾN PHẠM VỊ 
+ BIẾN TOÀN CỤC (GLOBAL) : khai báo ngoài hàm main 
+ BIẾN ĐỊA PHƯƠNG (LOCAL) : khai báo trong hàm main 
+ BIẾN NGOẶC NHỌN (ENCLOSING SCOPE) : trong main mà thêm ngoặc nhọn 
NOTE: ưu tiên ngoặc nhọn , rồi đến địa phương , cuối là toàn cục 
là nó tìm kiếm từ ngoặc nhọn đến địa phương rồi toàn cục 
int a=100;
  int b=200;
  if(true){
    int a=200;
    b=100;
  }
  cout<<a<<" "<<b;  // 100 100 
khi khai báo biến trước nó là gọi là biến gốc 
còn gán biến thì sẽ thay đổi giá trị ảnh hưởng biến gốc 
int i=1;
for(int i=1;i<=5;i++){
}
cout<<i; //chỉ khai báo số 1 thôi 
----------------------------------------------------------------------
CÔNG THỨC LẬT NGƯỢC : 
int rev = 0;
while (n > 0) {
  int digit = n % 10;
  rev = rev * 10 + digit;
  n = n / 10;
}
return rev;
CÁC BÀI TOÁN LIÊN QUAN ĐẾN ƯỚC NGUYÊN TỐ DÙNG THỪA SỐ NGUYÊN TỐ 
int soluong(int n){
  int dem=0;
  for(int i=2;i*i<=n;i++){
    if(n%i==0){
      dem++;
      while(n%i==0) n/=i;
    }
  }
  if(n>1) dem++;
  return dem;
}
_______________________________________________________________________
int ktra6(int n){
  int sum=0;
  while(n){
    sum=n%10;
    n/=10;
  }
  return sum%10==6;
}
lấy chữ số cuối cùng so sánh = 6 thôi 
vd n=36 -> lặp 1 sum = 6 lặp 2 sum=3 thoát khỏi thì sum = 3 thôi 
int ktra6(int n){
  while(n){
    if(n%10==6) return 1;  // kiểm tra từng số 
    n/=10;
  }
  return 0;
}
__________________________________________________________________________
THUẬN NGHỊCH: LÀ N == LẬT ví dụ 1234321 -> return n==ktra(n)  
TÍNH CHÊCH LỆCH TRONG N PHẢI BẰNG 1 : abs(n%10-(n/10)%10)!=1 return 0;
vd : 2345 thì lấy 5-4=1 nếu !=1 thì return 0;
TÍNH TỔNG CHÊCH LỆCH CỦA N : 1231 thì ta lấy 1-2,2-3,3-1 = 4 
int sum=0;
  while(n>=10){
    int r=n%10;  // lấy số cuối cùng 
    n/=10;      // xóa đi số cuối cùng 
    sum+=abs(r-n%10);   // lấy số cuối cùng trừ đi số gần cuối 
  }
  cout<<sum;
__________________________________________________________________________
TÌM SỐ LỚN NHẤT TRONG N : ta đặt int r=n%10 rồi so sánh 
đặt gán max_val=0; nên dùng while(n!=0) nó xét đến trường hợp cuối cùng 
if(r>max_val) max_val=r; cout<<max_val; 
KIỂM TRA SỐ ĐẦU TIÊN CÓ LỚN HƠN CÁC SỐ CÒN LẠI KHÔNG : tìm số lớn rồi ss 
dùng n/=10 thì ra số cuối cùng rồi lấy nó so sánh số lớn nhất 
int max_val=0;
  while(n>=10){
    int r=n%10;
    n/=10;
    if(r>max_val) max_val=r;
  }
if(n>=max_val) cout<<"yes";
else cout<<"no";
--------------------------------------------------------------------------
In ra các số trong dãy số 1, 2, 4, 7, 11, 16, 22.... mà nhỏ hơn hoặc bằng
N, các số trong dãy này có khoảng cách giữa các số tăng dần lên 1 đơn vị.
ll n; cin>>n;
int dem=1,kc=1;
for(int i=1;dem<=n;i++){
  cout<<dem<<" "; 
  dem+=i;                   
}
khi i=1 cout<<1 -> 1+=1 =2 
khi i=2 cout<<2 -> 2+=2 =4  
khi i=3 cout<<4 -> 4+=3 =7   
khi i=4 cout<<7 -> 7+=4=11 
khi i=5 cout<<11 -> 11+=5=16  
...
khi i=9 cout<<37 ->39+=9=48   
--------------------------------------------------------------------------
Số Nguyên Tố Có Các Chữ Số Nguyên Tố : cái nào nhanh nên đặt trước 
--------------------------------------------------------------------------
Goldbach conjecture : p<=n/2 nếu p<=n thì có thể bị trùng
int q=n-p; để lấy cặp nguyên tố đó 
--------------------------------------------------------------------------
Cặp số nguyên tố cùng nhau : dùng ước chung lớn nhất __gcd(i,j)==1
--------------------------------------------------------------------------
Tất cả các số có đúng ba ước số : thì nó chính là bình phương 
3 ước số chỉ khi nó là bình phương của một số nguyên tố.
ví dụ n^2 nó sẽ là 1 , n , n^2  thì có 3 ước nên cout<<i*i;
ví dụ n nó sẽ là 1 , n có 2 ước 
tại sao i*i<=n vì nó là bình phương khi bình lên số rất to khi cout<<i*i;
--------------------------------------------------------------------------
FIBONACCI : 0<=92 
    f(0)= 0.
    f(1)= 1.
    f(2)= 1.
    f(n)= f(n-1) +f(n-2) với n > 2.
___________________________________
bool fibo(ll n){
  if(n==0||n==1) return 1;
  ll f0=0,f1=1;
  for(int i=2;i<=92;i++){
    ll fn=f0+f1;
    if(n==fn) return 1;
    f0=f1;
    f1=fn;
  }
  return 0;
}
--------------------------------------------------------------------------
Lý thuyết đồng dư : khi tính tổng sum=(sum+n)%mod; 
--------------------------------------------------------------------------
Đếm ước của một số nguyên dương : ans*=(e+1) -> ans%=mod; 
Để tạo ra tất cả các ước số của 60, ta chọn:
số mũ của 2 có thể là: 0, 1, 2 (3 lựa chọn)
số mũ của 3 có thể là: 0, 1 (2 lựa chọn)
số mũ của 5 có thể là: 0, 1 (2 lựa chọn)
=> vì vậy nên phải cộng thêm 1 , và đặt ans=1 vì nó dùng tích 
--------------------------------------------------------------------------
Cho số tự nhiên N. Nhiệm vụ của bạn là in ra ước số nguyên tố nhỏ nhất của
các số từ 1 đến N. Ước số nguyên tố nhỏ nhất của 1 là 1. Ước số nguyên tố 
nhỏ nhất của các số chẫn là 2. Ước số nguyên tố nhỏ nhất của các số nguyên
tố là chính nó.
for(int i=1;i<=n;i++){
    if(i==1) cout<<1;
    else if(i%2==0) cout<<2;
    else if(ktra(i)) cout<<i;
    else {
      for(int j=3;j*j<=i;j+=2){ // khi i=9 -> 3*3<=9 
        if(i%j==0&&ktra(j)){  // 9%3=0 && ktra(3) thỏa mản nên in j
          cout<<j; break;    // in ra 3 
        } 
      }
    }
    cout<<endl;
}
--------------------------------------------------------------------------
Phân tích thừa số nguyên tố : nên đặt mu=0 trong for nếu ko là bị + dồn mũ
for(int i=2;i*i<=n;i++){
    if(n%i==0){
      int mu=0;
      while(n%i==0){
        mu++;
        n/=i;
      }
      cout<<i<<"^"<<mu;
    }
    cout<<" ";
}
if(n>1) cout<<n<<"^1";
--------------------------------------------------------------------------
Bậc của thừa số nguyên tố trong N! : tức la N! chia hết cho p^x 
(n/p)+(n/p^2)+(n/p^3)+...(n/p^n) -> lặp đến khi p^x > N 
ll gt(ll n, ll p){
  ll x=p;
  ll res=0;
  while(x<=n){
    res+=n/x;
    x*=p;
  }
  return res;
}
ví dụ n=30 , p=2 
x=2 , res=0 ; lần 1 0+=30/2=15 -> lần 2 15+=30/4=7 -> lần 3 22+=30/8=3 
-> lần 4 25+=30/16=1  -> lần 5 res=26 vì 16*2=32 > 30 nên dừng 
->x=2*2 = 4    ->x=4*2=8    ->x=8*2=16    ->x=16*2=32  
----------------------------------------------------------------------------
Đếm chữ số 0 liên tiếp tính từ cuối của N! : dùng bậc 5 để tìm 
ll gt(ll n, ll p){
  ll x=p;
  ll res=0;
  while(x<=n){
    res+=n/x; // bao nhiêu số 5 thì nó là số 10 
    x*=p; 
  }
  return res;
}
----------------------------------------------------------------------------
Số Sphenic : nếu mũ>2 thì nó không phải là số sphenic 
ll sphenic(ll n){
  int dem=0;
  for(ll i=2;i*i<=n;i++){
    if(n%i==0){
      int mu=0;
      while(n%i==0){
        mu++;
        n/=i;
      }
      if(mu>1) return 0;
      dem++;
      if(dem>3) return 0;
    }
  }
  if(n>1) dem++;
  return dem==3;
}
































































